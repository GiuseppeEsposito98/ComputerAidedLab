import numpy as np
import random

n = int(input("Number of balls and bins: "))


def simulation(n, typ = "random_drop"):
    if typ == "random_drop":
        bins = np.zeros(n)
        for _ in range(n):
            choice = np.random.choice(range(n))
            bins[choice] =  bins[choice] +1
        return bins
    elif typ == "random_load_balancing":
        d = int(input("Number of selected bins"))
        bins = np.zeros(n)
        selected_idx = np.random.randint(0,n)
        selected_bins = bins[selected_idx]
        ciao = list()
        for i,j in zip(selected_idx, selected_bins):
            ciao.append((i,j))
        min_ = min(ciao, key=lambda k: k[1])
        bins[min_[0]] = bins[min_[0]] + 1 
        print(bins)
'''
def simulation(n, typ = "random_drop"):
    if typ == "random_drop":
        bins = np.zeros(n)
        for _ in range(n):
            choice = np.random.choice(range(n))
            bins[choice] =  bins[choice] +1
        return bins
    elif typ == "random_load_balancing":
        d = int(input("Number of selected bins"))
        bins = np.zeros(n)
        for _ in range(n):
            selected_bins = np.random.choice(range(n), d)
            #print("selected_bins: ", selected_bins)
            min_val = np.min(bins[selected_bins])
            #print("min_val: ", min_val)
            position = bins[np.where(bins == min_val)][selected_bins]
            #print("position: ", position)
            if len(position[0]) > 1:
                #print("position[0]: ", position[0])
                idx_to_remove = random.choice(range(len(position[0]))) 
                #print("val_to_remove: ", idx_to_remove)
                selected_bins = np.delete(selected_bins, idx_to_remove)
                #print("selected_bins", selected_bins)
                min_val = np.min(bins[selected_bins])
                #print("min_val: ", min_val)
                position = np.where(bins[selected_bins] == min_val)
                #print("position: ", position)
                #print("position[0]: ", position[0])
                bins[position] =  bins[position] + 1
            else:
                bins[position] =  bins[position] + 1
                print(bins)
        print(bins)




simulation(n, typ = "random_load_balancing")

arr = np.array([1,2,3,4,4])

for i, v in enumerate(arr):
    print(i,v)

'''


pos = np.array([0,1])

val = np.array([1,1,3,4,5,6])

selected = val[pos]

ciao = list()
for i,j in zip(pos, selected):
    ciao.append((i,j))

min_tuple = min(ciao, key= lambda k : k[1]) # questo mi ritorna solo il minimo con l'indice minimo
print(min_tuple)
#val[min_tuple[0]] = val[min_tuple[0]] + 1
#print(val)